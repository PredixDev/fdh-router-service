{"name":"Fdh-router-service","tagline":"consumer","body":"<a href=\"../../../../pages/adoption/fdh-router-service/javadocs/index.html\" target=\"_blank\" >\r\n\t<img height=\"50px\" width=\"100px\" src=\"images/javadoc.png\" alt=\"view javadoc\"></a>\r\n&nbsp;\r\n<a href=\"../../../../pages/adoption/fdh-router-service\" target=\"_blank\">\r\n\t<img height=\"50px\" width=\"100px\" src=\"images/pages.jpg\" alt=\"view github pages\">\r\n</a>\r\nData Exchange Federated Data Handler\r\n==================\r\n\r\nData Exchange is a Federated Data Handler that routes Get/Put requests to a DataHandler. Data Exchange is be used to retrieve or store any Data Field from any Datasource with any Filter where clause.  \r\n\r\nPredixAssetHandler and PredixTimeseriesHandler are currently supported.  You can add Handlers to other datasources as needed.  The intent here is to create consistency across your apis in the cloud and on the edge allowing for data and algorithm portability.\r\n\r\n<img src=\"images/fdh_handlers.png\">\r\n\r\nAny service, such as [rmd-analytics](https://github.com/predixdev/rmd-analytics) or [Ingestion](https://github.com/predixdev/dataingestion-service) can leverage the Data Exchange to pass runtime requests to get or put data.  The api, architecture and implementation are portable beyond cloud microservices.  The api provides data resolution for any field from any datasource (customer specific datasources, files, hadoop, rdbms, cache, Asset, Timeseries, etc)\r\n\r\nRuntime resolution of Fields allows for saved Queries applied to Event data.  Once a Handler is written, you won't have to return to it.  This frees up the team to build more value-add services and not worry about the Data Retrieval and Storage.  Also you can swap out Data Sources quite easily by adding a different Handler.\r\n\r\n##Traversing the Model\r\n\r\nThe 'field' is nothing more than a URI representing attributes or entities in a source system.  E.g. the field /asset/assetId represents the assetId attribute on the Asset entity.  Or /address/addressLine1 represents the addressLine1 field on the Address entity.  \r\n\r\nIt turns out that all json structures are primitives, objects, maps or lists.  In this example, we search for an Asset trying to retrieve the OutputMaximum attribute.  The items in-between are a traversal of the Asset object-graph json.  Predix Asset supports any 'model' json structure.  In this case the model is an Asset.  But it could be /plane/wingspan or /address/city.  \r\n\r\n<img src=\"images/model_attribute.png\">\r\n\r\n>Our implementation uses standard json libraries to find the attribute within the model.  We use Jackson since it handles polymorphic objects better than Gson.  We also do not have to register mappers for each object type we create.  This should increase productivity since you can concentrate on Modeling and not the plumbing of marshaling/unmarshaling Json.\r\n\r\n##DataSource\r\n\r\nA Field uri represents a data attribute or entity, but where does that data come from?  You simply define the Source in the GET request and the router sends the GET or PUT request on to the right Handler.  In this example the data source for outputMaximum of crank-frame-discharge-pressure on an AssetTag on an Asset named Compressor-2015, is PREDIX_ASSET, so the GET request is simply forwarded on to the PredixAssetHandler.\r\n\r\n```json\r\n\r\n\t\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\t\"id\": \"/asset/assetTag/crank-frame-dischargepressure/outputMaximum\",\r\n\t\t\t\t\t\t\"source\": \"PREDIX_ASSET\"\r\n\t\t\t\t\t},\r\n\t\t\t\t\t\"expectedDataType\": \"DMReal\",\r\n\t\t\t\t\t\"resultId\": \"ALARM_HI\"\r\n```\r\n\r\nThis nice thing to notice here is that Configuring this GET request ahead of time, allows for late data-binding at runtime from any Data Source.\r\n\r\n##GetFieldData - GET\r\n(future)The current GetData api uses a POST body.  Using Rest semantics it should be quite easy to create a Rest GET api accessing any field in any datasource.\r\n\r\n##GetFieldData - RelationalDBHandler - POST\r\n(future)Seemlessly mapping these Rest semantics to SQL semantics has been done in the past but is not ported to the cloud.  This allows the traversal of any Object/Relational Graph relative to an 'id', such as an assetId.  \r\n\r\n##GetFieldData - PredixAssetHandler - POST\r\nThe GetFieldData api has a simple List of Criteria, shown below.  Each criteria has a FieldIdentifier and a Filter.  In this example we are retreiving the outputMaximum attribute on an Asset.AssetTag(\"crank-frame-dischargepressure\") where /asset/assetId = \"/asset/compressor-2015\".  AssetTag is a map.  \r\n\r\nNotice the use of the FieldIdentifier object, you'll see this alot and the id and source is how the api handles Federated datasources.  Also note the FieldIdentifier is typed.  Identifier (CustomerIdentifier, TurbineIdentifier, AddressIdentier, etc) has polymorphic semantics so you can have a list of varying ids, very helpful in a SOA.\r\n\r\n```json\r\n{\r\n\t\t\t\"fieldSelection\": \r\n\t\t\t[\r\n\t\t\t\t{\r\n\t\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\t\"id\": \"/asset/assetTag/crank-frame-dischargepressure/outputMaximum\",\r\n\t\t\t\t\t\t\"source\": \"PREDIX_ASSET\"\r\n\t\t\t\t\t},\r\n\t\t\t\t\t\"expectedDataType\": \"DMReal\",\r\n\t\t\t\t\t\"resultId\": \"ALARM_HI\"\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\t\"filter\": \r\n\t\t\t{\r\n\t\t\t\t\"complexType\": \"FieldFilter\",\r\n\t\t\t\t\"fieldIdentifierValue\": \r\n\t\t\t\t[\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\t\t\"id\": \"/asset/assetId\",\r\n\t\t\t\t\t\t\t\"source\": \"PREDIX_ASSET\"\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\"value\": \"/asset/compressor-2015\"\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t},\r\n\t\t\t\"resultId\": \"ALARM_HI\"\r\n\t\t}\r\n```\r\n\r\nHere is the same structure in a picture.  Defined in an xsd, the service can handle JSON or XML seemlessly at runtime simply by passing an HTTP Header of Content-Type : application/json or application/xml, but we think the JSON is nicer to look at.\r\n\r\n<img src=\"images/criteria.png\">\r\n\r\nThe FieldIdentifer has an id, name, and source.  The id is a Rest principle based string indicating where to find the Real, Int, String, Bool, Timeseries or other attribute.  As mentioned, the \"source\" drives Routing decisions to Handlers.  More rules based routing can be employed yourself as a custom situation.\r\n\r\n<img src=\"images/field_identifier.png\">\r\n\r\nThe Selection Filter is a where clause which has Animal, Cat, Dog polymorphic semantics.  We can define any Filter we want.  We have defined 2 Filters which will take you a long way in Predix.  A TimeFilter which mirrors the Predix Timeseries API and simply 'extends' Filter.  And a FieldFilter which allows for basic AND/OR semantics similar to a where clause.    Filters can return multiple Models (like rows in a database) and thus actions can be performed on the set of data returned.\r\n\r\n<img src=\"images/predix-time-selection-filter.png\">\r\n\r\n<img src=\"images/field-selection-filter.png\">\r\n\r\n##PutFieldData\r\n\r\nThis is a PutFieldDataCriteria setting the alertStatus attribute to false.  The object traversal is a little long due to historic factors.  This is from a working anlaytics example where we can jump to another Model in Predix Asset, in this case the TagExtensions model.  In other words, we searched for an Asset but the alertStatus.value is from a second query for TagExtensions following the TagExtensions.uri much like a foreign key.  The PredixAssetHandler does all this traversal seemlessly, you can define Fields without having to code the object graph traversal each time.  This allows you to solve the problem at hand and not worry about the Json Objects.\r\n\r\n```json\r\n\"putFieldDataCriteria\": \r\n\t[\r\n\t\t{\r\n\t\t\t\"fieldData\": \r\n\t\t\t{\r\n\t\t\t\t\"field\": \r\n\t\t\t\t{\r\n\t\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\t\"id\": \"/asset/assetTag/crank-frame-dischargepressure/tagDatasource/tagExtensions/attributes/alertStatus/value\",\r\n\t\t\t\t\t\t\"source\": \"PREDIX_ASSET\"\r\n\t\t\t\t\t},\r\n\t\t\t\t},\r\n\t\t\t\t\"data\": \r\n\t\t\t\t{\r\n\t\t\t\t\t\"complexType\": \"OsaData\",\r\n\t\t\t\t\t\"dataEvent\": \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"complexType\": \"DMBool\",\r\n\t\t\t\t\t\t\"value\": false\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t\"filter\": \r\n\t\t\t{\r\n\t\t\t\t\"complexType\": \"FieldFilter\",\r\n\t\t\t\t\"fieldIdentifierValue\": \r\n\t\t\t\t[\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\t\t\"id\": \"/asset/assetId\",\r\n\t\t\t\t\t\t\t\"source\": \"PREDIX_ASSET\"\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\"value\": \"/asset/compressor-2015\"\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t}\r\n\t]\r\n```\r\n\r\n##GetFieldDataResult\r\n\r\nThe GetFieldDataResult and PutFieldDataRequest use a FieldData structure.  The Field represents the attribute for which the Data is for.  The Data also has Animal, Cat, Dog polymorphic semantics and can be any Data structure that you define.  Since this is the Industrial Internet, engineering units are also defined.\r\n\r\n(future) Solution Services will provide an Engineering Unit converter service tile in the cloud.\r\n\r\n<img src=\"images/fieldData.png\">\r\n\r\n##Data\r\n\r\nThe most common data structures are Real, Int, Boolean, String, Timeseries, but any Data Type can be defined.  We recommend updating only single attributes within a larger structure.  This allows long-running algorithms to not update stale data.  (future) We recommend an optimistic locking technique be employed as a best-practice.\r\n\r\nThis is a notional image just to give a quick overview of the common types of data.  The actual structure varies.\r\n<img src=\"images/common-data-types.png\">\r\n\r\n##Summary\r\n\r\nTo summarize, Data Exchange can get Data for any Field from any Source using any Filter.  @Data, @Filter and @Identifier are extensible so any shape or structure of Data, Where Clause, or Id are supported.  Now you can save your requests and responses and do late data-binding for retrieving or storing data at the edge or in the cloud.  When you visit the sample [rmd-analytics](https://github.com/predixdev/rmd-analytics) API, you'll see Data Exchange works in tandem to accomplish this late data-binding for reusable Analytics.\r\n\r\n##Tech Stack\r\n- Spring\r\n- SpringBoot\r\n- SpringTest\r\n- Maven\r\n\r\n##Microcomponents\r\n- [AssetBootstrap](https://github.com/predixdev/asset-bootstrap)\r\n- [TimeseriesBootstrap](https://github.com/predixdev/timeseries-bootstrap)\r\n- [PredixBoot](https://github.com/predixdev/predix-boot)\r\n- [PredixRestClient](https://github.com/predixdev/predix-boot)\r\n\r\n### More Details\r\n* [More GE resources](http://github.com/predixdev/predix-rmd-ref-app/docs/resources.md)\r\n* [RMD Reference App](http://github.com/predixdev/predix-rmd-ref-app)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}